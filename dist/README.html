<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<p><strong>Table of Contents</strong>  <em>generated with <a href="https://github.com/thlorenz/doctoc">DocToc</a></em></p>
<ul>
<li><a href="#nutmeg">Nutmeg</a><ul>
<li><a href="#why">Why?</a></li>
<li><a href="#whats-wrong-with">What&#39;s wrong with?</a></li>
<li><a href="#what-does-it-look-like">What does it look like?</a><ul>
<li><a href="#structure">Structure:</a></li>
<li><a href="#modifiers">Modifiers:</a></li>
<li><a href="#style">Style:</a></li>
<li><a href="#repetition">Repetition:</a></li>
</ul>
</li>
<li><a href="#getting-set-up">Getting set up</a></li>
</ul>
</li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h1 id="nutmeg">Nutmeg</h1>
<p>A tiny website generator.
All nutmeg code is client-side javascript.</p>
<h2 id="why-">Why?</h2>
<ul>
<li>Neater syntax than HTML</li>
<li>Avoid code repetition</li>
<li>Better abstraction</li>
<li>Improve maintainability</li>
<li>Reduce code size</li>
<li>Reduce bandwidth usage</li>
<li>Reduce load time</li>
</ul>
<h2 id="what-s-wrong-with-">What&#39;s wrong with?</h2>
<ul>
<li>Pre-processors:<ul>
<li>Produce <em>large</em> amounts of code</li>
</ul>
</li>
<li>The big guys (React / Angular / Other)<ul>
<li>Try to do too many things</li>
<li>Are massive libraries</li>
<li>Dictate code style / data flow</li>
</ul>
</li>
</ul>
<h2 id="what-does-it-look-like-">What does it look like?</h2>
<h3 id="structure-">Structure:</h3>
<p>Nutmeg&#39;s goal is to have the cleanest syntax possible, as such, nutmeg has no<br>closing tags. Every element is a javascript function.</p>
<pre><code class="lang-js">body(
    div(
        h1(&#39;Nutmeg&#39;),
            &#39;Hello World&#39;,
            div(
                div(
                &quot;Don&#39;t disturb my nest!&quot;,
                br(),
                &quot;Thanks.&quot;,
                br(),
                a(&#39;Take me to the nutmeg repo&#39;).href(&#39;https://github.com/414owen/Nutmeg&#39;)
            )
        )
    )
)
</code></pre>
<h3 id="modifiers-">Modifiers:</h3>
<p>Modifiers change a nutmeg element, then return the element. This allows us to<br>chain modifiers together very neatly. We have already seen a modifier above.</p>
<pre><code class="lang-js">var upper = h1();

...

form(
    result,
    input()
        .placeholder(&#39;Type here&#39;)
        .onkeyup(function(e) {
            result.clear()(e.target.value)
        }),
    button(&#39;Submit&#39;).onclick(function(e) {console.log(e)})
)
</code></pre>
<p>There is a shortcut to calling modifiers, which doesn&#39;t involve creating the<br>element explicitly first.</p>
<pre><code class="lang-js">// create input, then apply modifier
input().placeholder(&#39;hello&#39;)

// is the exact same as
input.placeholder(&#39;hello&#39;)
</code></pre>
<p>Also, as the modifiers return a nutmeg element, we can call the modified element<br>to add children. This allows modifiers to be used before and after adding<br>children.</p>
<pre><code class="lang-js">// create element with children
div(
    &#39;The answer is: &#39;,
    42
).style({fontSize: &#39;42px&#39;})

// is the exact same as
div.style({fontSize: &#39;42px&#39;})(
    &#39;The answer is: &#39;,
    42
)

// is the exact same as
div(&#39;The answer is: &#39;)
    .style({fontSize: &#39;42px&#39;})(42)
</code></pre>
<h3 id="style-">Style:</h3>
<p>As seen above, styles can be applied directly using object literals. For a<br>better system, involving dependencies, pseudo-elements and all sorts of fun, we<br>create a style object.</p>
<pre><code>var style = mergeStyle({
    base: {
        backgroundColor: &#39;#ccc&#39;,
        fontSize: &#39;20px&#39;
    },
    bordered: {
        borderRadius: &#39;8px&#39;,
        border: &#39;1px solid #111&#39;
    },
    example: {
        depends: [&#39;bordered&#39;, &#39;base&#39;],
        padding: &#39;20px&#39;
    }
});
</code></pre><p>This structure, on its own does nothing. We would apply it with the <code>.style</code><br>modifier, for example:</p>
<pre><code>div.style(style.example)(&#39;Hello World&#39;)
</code></pre><p>With regards to dependencies, you can have as many as you want, and they will be<br>applied recursively in the order they are declared, so you can overwrite styles<br>from your dependencies easily.</p>
<h3 id="repetition-">Repetition:</h3>
<p>Nutmeg parameters can be other nutmeg elements, anything that can be stringified<br>(eg. numbers), or array-like objects of these. To show this, we will generate an<br>array of the first 500 fibonacci numbers, and append it to body.</p>
<pre><code>
// Generate an array of the first 500 fibonacci numbers
var curr = 1;
var prev = 0;
var fibs = Array.apply(0, Array(500)).map(
    function (fib, ind) {
        var oldc = curr, oldp = prev;
        curr += prev;
        prev = oldc;
        return oldp;
    }
)

// body is taking an array of nutmeg elements
body(
    fibs.map(function(fib) {
        // div is taking a number
        return div(fib).style({margin: &#39;20px&#39;});
    })
);
</code></pre><h2 id="getting-set-up">Getting set up</h2>
<ul>
<li>Create your html page</li>
<li>Include the nutmeg library using a script tag or otherwise</li>
<li>Paste this into your javascript file:</li>
</ul>
<pre><code>window.onload = function() {
    // Declare all nutmeg functions locally
    var nut = nutmeg();
    for (var key in nut) {
        eval(&#39;var &#39; + key + &#39;=nut[key];&#39;);
    }

    // * Insert your nutmeg code here *

}
</code></pre><ul>
<li>Write some code</li>
</ul>
<p>You can of course use your own way of running code when the document is ready,<br>and you don&#39;t have to declare nutmeg functions locally, you can do something<br>like: </p>
<pre><code>var n = nutmeg();
n.div(
    &#39;Hello World&#39;
    n.input.type(&#39;file&#39;)
)
</code></pre>